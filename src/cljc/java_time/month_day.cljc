(ns cljc.java-time.month-day (:require [cljs.java-time.interop :as jti] #? (:cljs [java.time :refer [MonthDay]])) (:refer-clojure :exclude [get range format min max next name resolve]) #? (:clj (:import [java.time MonthDay])))
(clojure.core/defn at-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.LocalDate [^java.time.MonthDay this2751 ^java.lang.Integer int2752] (.atYear this2751 int2752)))
(clojure.core/defn range {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.MonthDay this2753 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2754] (.range this2753 java-time-temporal-TemporalField2754)))
(clojure.core/defn of {:arglists (quote (["java.time.Month" "int"] ["int" "int"]))} (^java.time.MonthDay [G__2756 G__2757] #? (:cljs (. java.time.MonthDay of G__2756 G__2757) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Month") G__2756) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__2757)) (clojure.core/let [G__2756 ^"java.time.Month" G__2756 G__2757 (clojure.core/int G__2757)] (. java.time.MonthDay of G__2756 G__2757)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__2756) (clojure.core/instance? (java.lang.Class/forName "java.lang.Number") G__2757)) (clojure.core/let [G__2756 (clojure.core/int G__2756) G__2757 (clojure.core/int G__2757)] (. java.time.MonthDay of G__2756 G__2757)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn with-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this2758 ^java.lang.Integer int2759] (.withMonth this2758 int2759)))
(clojure.core/defn query {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.MonthDay this2760 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery2761] (.query this2760 java-time-temporal-TemporalQuery2761)))
(clojure.core/defn to-string {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.String [^java.time.MonthDay this2762] (.toString this2762)))
(clojure.core/defn is-before {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this2763 ^java.time.MonthDay java-time-MonthDay2764] (.isBefore this2763 java-time-MonthDay2764)))
(clojure.core/defn get-long {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^long [^java.time.MonthDay this2765 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2766] (.getLong this2765 java-time-temporal-TemporalField2766)))
(clojure.core/defn with-day-of-month {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.time.MonthDay [^java.time.MonthDay this2767 ^java.lang.Integer int2768] (.withDayOfMonth this2767 int2768)))
(clojure.core/defn get-day-of-month {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this2769] (jti/getter dayOfMonth this2769)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.MonthDay [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor2770] (. java.time.MonthDay from java-time-temporal-TemporalAccessor2770)))
(clojure.core/defn is-after {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"]))} (^java.lang.Boolean [^java.time.MonthDay this2771 ^java.time.MonthDay java-time-MonthDay2772] (.isAfter this2771 java-time-MonthDay2772)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Boolean [^java.time.MonthDay this2773 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2774] (.isSupported this2773 java-time-temporal-TemporalField2774)))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"] ["java.lang.CharSequence" "java.time.format.DateTimeFormatter"]))} (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence2775] (. java.time.MonthDay parse java-lang-CharSequence2775)) (^java.time.MonthDay [^java.lang.CharSequence java-lang-CharSequence2776 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter2777] (. java.time.MonthDay parse java-lang-CharSequence2776 java-time-format-DateTimeFormatter2777)))
(clojure.core/defn is-valid-year {:arglists (quote (["java.time.MonthDay" "int"]))} (^java.lang.Boolean [^java.time.MonthDay this2778 ^java.lang.Integer int2779] (.isValidYear this2778 int2779)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this2780] (.hashCode this2780)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.MonthDay" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.MonthDay this2781 ^java.time.temporal.Temporal java-time-temporal-Temporal2782] (.adjustInto this2781 java-time-temporal-Temporal2782)))
(clojure.core/defn with {:arglists (quote (["java.time.MonthDay" "java.time.Month"]))} (^java.time.MonthDay [^java.time.MonthDay this2783 ^java.time.Month java-time-Month2784] (.with this2783 java-time-Month2784)))
(clojure.core/defn now {:arglists (quote (["java.time.ZoneId"] [] ["java.time.Clock"]))} (^java.time.MonthDay [G__2786] #? (:cljs (. java.time.MonthDay now G__2786) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.ZoneId") G__2786)) (clojure.core/let [G__2786 ^"java.time.ZoneId" G__2786] (. java.time.MonthDay now G__2786)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Clock") G__2786)) (clojure.core/let [G__2786 ^"java.time.Clock" G__2786] (. java.time.MonthDay now G__2786)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.time.MonthDay [] (. java.time.MonthDay now)))
(clojure.core/defn get-month-value {:arglists (quote (["java.time.MonthDay"]))} (^java.lang.Integer [^java.time.MonthDay this2787] (jti/getter monthValue this2787)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.MonthDay" "java.time.MonthDay"] ["java.time.MonthDay" "java.lang.Object"]))} (^java.lang.Integer [this2788 G__2789] #? (:cljs (.compareTo ^java.time.MonthDay this2788 G__2789) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.MonthDay") G__2789)) (clojure.core/let [G__2789 ^"java.time.MonthDay" G__2789] (.compareTo ^java.time.MonthDay this2788 G__2789)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__2789)) (clojure.core/let [G__2789 ^"java.lang.Object" G__2789] (.compareTo ^java.time.MonthDay this2788 G__2789)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn get-month {:arglists (quote (["java.time.MonthDay"]))} (^java.time.Month [^java.time.MonthDay this2790] (jti/getter month this2790)))
(clojure.core/defn get {:arglists (quote (["java.time.MonthDay" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.MonthDay this2791 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2792] (.get this2791 java-time-temporal-TemporalField2792)))
(clojure.core/defn equals {:arglists (quote (["java.time.MonthDay" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.MonthDay this2793 ^java.lang.Object java-lang-Object2794] (.equals this2793 java-lang-Object2794)))
(clojure.core/defn format {:arglists (quote (["java.time.MonthDay" "java.time.format.DateTimeFormatter"]))} (^java.lang.String [^java.time.MonthDay this2795 ^java.time.format.DateTimeFormatter java-time-format-DateTimeFormatter2796] (.format this2795 java-time-format-DateTimeFormatter2796)))
