(ns cljc.java-time.instant (:require [cljs.java-time.interop :as jti] #? (:cljs [java.time :refer [Instant]])) (:refer-clojure :exclude [get range format min max next name resolve]) #? (:clj (:import [java.time Instant])))
(def min (. java.time.Instant -MIN))
(def epoch (. java.time.Instant -EPOCH))
(def max (. java.time.Instant -MAX))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"]))} (^java.time.Instant [^java.time.Instant this2356 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit2357] (.truncatedTo this2356 java-time-temporal-TemporalUnit2357)))
(clojure.core/defn range {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Instant this2358 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2359] (.range this2358 java-time-temporal-TemporalField2359)))
(clojure.core/defn of-epoch-second {:arglists (quote (["long" "long"] ["long"]))} (^java.time.Instant [^long long2360 ^long long2361] (. java.time.Instant ofEpochSecond long2360 long2361)) (^java.time.Instant [^long long2362] (. java.time.Instant ofEpochSecond long2362)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.Instant" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.Instant this2363 ^java.time.ZoneOffset java-time-ZoneOffset2364] (.atOffset this2363 java-time-ZoneOffset2364)))
(clojure.core/defn minus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2365 ^long long2366] (.minusMillis this2365 long2366)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this2367] (jti/getter nano this2367)))
(clojure.core/defn plus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2368 ^long long2369] (.plusMillis this2368 long2369)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2370 ^long long2371] (.minusSeconds this2370 long2371)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2372 ^long long2373] (.plusNanos this2372 long2373)))
(clojure.core/defn plus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this2374 G__2375 G__2376] #? (:cljs (.plus ^java.time.Instant this2374 G__2375 G__2376) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2375) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2376)) (clojure.core/let [G__2375 (clojure.core/long G__2375) G__2376 ^"java.time.temporal.TemporalUnit" G__2376] (.plus ^java.time.Instant this2374 G__2375 G__2376)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2375) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2376)) (clojure.core/let [G__2375 (clojure.core/long G__2375) G__2376 ^"java.time.temporal.TemporalUnit" G__2376] (.plus ^java.time.Instant this2374 G__2375 G__2376)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2377 G__2378] #? (:cljs (.plus ^java.time.Instant this2377 G__2378) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2378)) (clojure.core/let [G__2378 ^"java.time.temporal.TemporalAmount" G__2378] (.plus ^java.time.Instant this2377 G__2378)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2378)) (clojure.core/let [G__2378 ^"java.time.temporal.TemporalAmount" G__2378] (.plus ^java.time.Instant this2377 G__2378)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn query {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Instant this2379 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery2380] (.query this2379 java-time-temporal-TemporalQuery2380)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Instant"]))} (^java.lang.String [^java.time.Instant this2381] (.toString this2381)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this2382 ^java.time.Instant java-time-Instant2383] (.isBefore this2382 java-time-Instant2383)))
(clojure.core/defn minus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this2384 G__2385 G__2386] #? (:cljs (.minus ^java.time.Instant this2384 G__2385 G__2386) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2385) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2386)) (clojure.core/let [G__2385 (clojure.core/long G__2385) G__2386 ^"java.time.temporal.TemporalUnit" G__2386] (.minus ^java.time.Instant this2384 G__2385 G__2386)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2385) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2386)) (clojure.core/let [G__2385 (clojure.core/long G__2385) G__2386 ^"java.time.temporal.TemporalUnit" G__2386] (.minus ^java.time.Instant this2384 G__2385 G__2386)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2387 G__2388] #? (:cljs (.minus ^java.time.Instant this2387 G__2388) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2388)) (clojure.core/let [G__2388 ^"java.time.temporal.TemporalAmount" G__2388] (.minus ^java.time.Instant this2387 G__2388)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__2388)) (clojure.core/let [G__2388 ^"java.time.temporal.TemporalAmount" G__2388] (.minus ^java.time.Instant this2387 G__2388)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.ZonedDateTime [^java.time.Instant this2389 ^java.time.ZoneId java-time-ZoneId2390] (.atZone this2389 java-time-ZoneId2390)))
(clojure.core/defn of-epoch-milli {:arglists (quote (["long"]))} (^java.time.Instant [^long long2391] (. java.time.Instant ofEpochMilli long2391)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^long [^java.time.Instant this2392 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2393] (.getLong this2392 java-time-temporal-TemporalField2393)))
(clojure.core/defn until {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Instant this2394 ^java.time.temporal.Temporal java-time-temporal-Temporal2395 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit2396] (.until this2394 java-time-temporal-Temporal2395 java-time-temporal-TemporalUnit2396)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Instant [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor2397] (. java.time.Instant from java-time-temporal-TemporalAccessor2397)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this2398 ^java.time.Instant java-time-Instant2399] (.isAfter this2398 java-time-Instant2399)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2400 ^long long2401] (.minusNanos this2400 long2401)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"] ["java.time.Instant" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this2402 G__2403] #? (:cljs (.isSupported ^java.time.Instant this2402 G__2403) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2403)) (clojure.core/let [G__2403 ^"java.time.temporal.TemporalField" G__2403] (.isSupported ^java.time.Instant this2402 G__2403)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__2403)) (clojure.core/let [G__2403 ^"java.time.temporal.TemporalUnit" G__2403] (.isSupported ^java.time.Instant this2402 G__2403)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"]))} (^java.time.Instant [^java.lang.CharSequence java-lang-CharSequence2404] (. java.time.Instant parse java-lang-CharSequence2404)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this2405] (.hashCode this2405)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Instant this2406 ^java.time.temporal.Temporal java-time-temporal-Temporal2407] (.adjustInto this2406 java-time-temporal-Temporal2407)))
(clojure.core/defn with {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this2408 G__2409] #? (:cljs (.with ^java.time.Instant this2408 G__2409) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2409)) (clojure.core/let [G__2409 ^"java.time.temporal.TemporalAdjuster" G__2409] (.with ^java.time.Instant this2408 G__2409)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__2409)) (clojure.core/let [G__2409 ^"java.time.temporal.TemporalAdjuster" G__2409] (.with ^java.time.Instant this2408 G__2409)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this2410 G__2411 G__2412] #? (:cljs (.with ^java.time.Instant this2410 G__2411 G__2412) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2411) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2412)) (clojure.core/let [G__2411 ^"java.time.temporal.TemporalField" G__2411 G__2412 (clojure.core/long G__2412)] (.with ^java.time.Instant this2410 G__2411 G__2412)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__2411) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__2412)) (clojure.core/let [G__2411 ^"java.time.temporal.TemporalField" G__2411 G__2412 (clojure.core/long G__2412)] (.with ^java.time.Instant this2410 G__2411 G__2412)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"]))} (^java.time.Instant [] (. java.time.Instant now)) (^java.time.Instant [^java.time.Clock java-time-Clock2413] (. java.time.Instant now java-time-Clock2413)))
(clojure.core/defn to-epoch-milli {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this2414] (.toEpochMilli this2414)))
(clojure.core/defn get-epoch-second {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this2415] (jti/getter epochSecond this2415)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Instant" "java.lang.Object"] ["java.time.Instant" "java.time.Instant"]))} (^java.lang.Integer [this2416 G__2417] #? (:cljs (.compareTo ^java.time.Instant this2416 G__2417) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__2417)) (clojure.core/let [G__2417 ^"java.lang.Object" G__2417] (.compareTo ^java.time.Instant this2416 G__2417)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Instant") G__2417)) (clojure.core/let [G__2417 ^"java.time.Instant" G__2417] (.compareTo ^java.time.Instant this2416 G__2417)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this2418 ^long long2419] (.plusSeconds this2418 long2419)))
(clojure.core/defn get {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Instant this2420 ^java.time.temporal.TemporalField java-time-temporal-TemporalField2421] (.get this2420 java-time-temporal-TemporalField2421)))
(clojure.core/defn equals {:arglists (quote (["java.time.Instant" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Instant this2422 ^java.lang.Object java-lang-Object2423] (.equals this2422 java-lang-Object2423)))
