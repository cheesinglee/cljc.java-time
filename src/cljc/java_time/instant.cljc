(ns cljc.java-time.instant (:require [cljs.java-time.interop :as jti] #? (:cljs [java.time :refer [Instant]])) (:refer-clojure :exclude [get range format min max next name resolve]) #? (:clj (:import [java.time Instant])))
(def min (. java.time.Instant -MIN))
(def epoch (. java.time.Instant -EPOCH))
(def max (. java.time.Instant -MAX))
(clojure.core/defn truncated-to {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalUnit"]))} (^java.time.Instant [^java.time.Instant this13282 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit13283] (.truncatedTo this13282 java-time-temporal-TemporalUnit13283)))
(clojure.core/defn range {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.time.temporal.ValueRange [^java.time.Instant this13284 ^java.time.temporal.TemporalField java-time-temporal-TemporalField13285] (.range this13284 java-time-temporal-TemporalField13285)))
(clojure.core/defn of-epoch-second {:arglists (quote (["long" "long"] ["long"]))} (^java.time.Instant [^long long13286 ^long long13287] (. java.time.Instant ofEpochSecond long13286 long13287)) (^java.time.Instant [^long long13288] (. java.time.Instant ofEpochSecond long13288)))
(clojure.core/defn at-offset {:arglists (quote (["java.time.Instant" "java.time.ZoneOffset"]))} (^java.time.OffsetDateTime [^java.time.Instant this13289 ^java.time.ZoneOffset java-time-ZoneOffset13290] (.atOffset this13289 java-time-ZoneOffset13290)))
(clojure.core/defn minus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this13291 ^long long13292] (.minusMillis this13291 long13292)))
(clojure.core/defn get-nano {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this13293] (jti/getter nano this13293)))
(clojure.core/defn plus-millis {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this13294 ^long long13295] (.plusMillis this13294 long13295)))
(clojure.core/defn minus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this13296 ^long long13297] (.minusSeconds this13296 long13297)))
(clojure.core/defn plus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this13298 ^long long13299] (.plusNanos this13298 long13299)))
(clojure.core/defn plus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"]))} (^java.lang.Object [this13300 G__13301 G__13302] #? (:cljs (.plus ^java.time.Instant this13300 G__13301 G__13302) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__13301) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__13302)) (clojure.core/let [G__13301 (clojure.core/long G__13301) G__13302 ^"java.time.temporal.TemporalUnit" G__13302] (.plus ^java.time.Instant this13300 G__13301 G__13302)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__13301) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__13302)) (clojure.core/let [G__13301 (clojure.core/long G__13301) G__13302 ^"java.time.temporal.TemporalUnit" G__13302] (.plus ^java.time.Instant this13300 G__13301 G__13302)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this13303 G__13304] #? (:cljs (.plus ^java.time.Instant this13303 G__13304) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__13304)) (clojure.core/let [G__13304 ^"java.time.temporal.TemporalAmount" G__13304] (.plus ^java.time.Instant this13303 G__13304)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__13304)) (clojure.core/let [G__13304 ^"java.time.temporal.TemporalAmount" G__13304] (.plus ^java.time.Instant this13303 G__13304)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn query {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalQuery"]))} (^java.lang.Object [^java.time.Instant this13305 ^java.time.temporal.TemporalQuery java-time-temporal-TemporalQuery13306] (.query this13305 java-time-temporal-TemporalQuery13306)))
(clojure.core/defn to-string {:arglists (quote (["java.time.Instant"]))} (^java.lang.String [^java.time.Instant this13307] (.toString this13307)))
(clojure.core/defn is-before {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this13308 ^java.time.Instant java-time-Instant13309] (.isBefore this13308 java-time-Instant13309)))
(clojure.core/defn minus {:arglists (quote (["java.time.Instant" "long" "java.time.temporal.TemporalUnit"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "java.time.temporal.TemporalAmount"] ["java.time.Instant" "long" "java.time.temporal.TemporalUnit"]))} (^java.lang.Object [this13310 G__13311 G__13312] #? (:cljs (.minus ^java.time.Instant this13310 G__13311 G__13312) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__13311) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__13312)) (clojure.core/let [G__13311 (clojure.core/long G__13311) G__13312 ^"java.time.temporal.TemporalUnit" G__13312] (.minus ^java.time.Instant this13310 G__13311 G__13312)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__13311) (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__13312)) (clojure.core/let [G__13311 (clojure.core/long G__13311) G__13312 ^"java.time.temporal.TemporalUnit" G__13312] (.minus ^java.time.Instant this13310 G__13311 G__13312)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this13313 G__13314] #? (:cljs (.minus ^java.time.Instant this13313 G__13314) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__13314)) (clojure.core/let [G__13314 ^"java.time.temporal.TemporalAmount" G__13314] (.minus ^java.time.Instant this13313 G__13314)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAmount") G__13314)) (clojure.core/let [G__13314 ^"java.time.temporal.TemporalAmount" G__13314] (.minus ^java.time.Instant this13313 G__13314)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn at-zone {:arglists (quote (["java.time.Instant" "java.time.ZoneId"]))} (^java.time.ZonedDateTime [^java.time.Instant this13315 ^java.time.ZoneId java-time-ZoneId13316] (.atZone this13315 java-time-ZoneId13316)))
(clojure.core/defn of-epoch-milli {:arglists (quote (["long"]))} (^java.time.Instant [^long long13317] (. java.time.Instant ofEpochMilli long13317)))
(clojure.core/defn get-long {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^long [^java.time.Instant this13318 ^java.time.temporal.TemporalField java-time-temporal-TemporalField13319] (.getLong this13318 java-time-temporal-TemporalField13319)))
(clojure.core/defn until {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal" "java.time.temporal.TemporalUnit"]))} (^long [^java.time.Instant this13320 ^java.time.temporal.Temporal java-time-temporal-Temporal13321 ^java.time.temporal.TemporalUnit java-time-temporal-TemporalUnit13322] (.until this13320 java-time-temporal-Temporal13321 java-time-temporal-TemporalUnit13322)))
(clojure.core/defn from {:arglists (quote (["java.time.temporal.TemporalAccessor"]))} (^java.time.Instant [^java.time.temporal.TemporalAccessor java-time-temporal-TemporalAccessor13323] (. java.time.Instant from java-time-temporal-TemporalAccessor13323)))
(clojure.core/defn is-after {:arglists (quote (["java.time.Instant" "java.time.Instant"]))} (^java.lang.Boolean [^java.time.Instant this13324 ^java.time.Instant java-time-Instant13325] (.isAfter this13324 java-time-Instant13325)))
(clojure.core/defn minus-nanos {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this13326 ^long long13327] (.minusNanos this13326 long13327)))
(clojure.core/defn is-supported {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"] ["java.time.Instant" "java.time.temporal.TemporalUnit"]))} (^java.lang.Boolean [this13328 G__13329] #? (:cljs (.isSupported ^java.time.Instant this13328 G__13329) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__13329)) (clojure.core/let [G__13329 ^"java.time.temporal.TemporalField" G__13329] (.isSupported ^java.time.Instant this13328 G__13329)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalUnit") G__13329)) (clojure.core/let [G__13329 ^"java.time.temporal.TemporalUnit" G__13329] (.isSupported ^java.time.Instant this13328 G__13329)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn parse {:arglists (quote (["java.lang.CharSequence"]))} (^java.time.Instant [^java.lang.CharSequence java-lang-CharSequence13330] (. java.time.Instant parse java-lang-CharSequence13330)))
(clojure.core/defn hash-code {:arglists (quote (["java.time.Instant"]))} (^java.lang.Integer [^java.time.Instant this13331] (.hashCode this13331)))
(clojure.core/defn adjust-into {:arglists (quote (["java.time.Instant" "java.time.temporal.Temporal"]))} (^java.time.temporal.Temporal [^java.time.Instant this13332 ^java.time.temporal.Temporal java-time-temporal-Temporal13333] (.adjustInto this13332 java-time-temporal-Temporal13333)))
(clojure.core/defn with {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField" "long"] ["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalAdjuster"] ["java.time.Instant" "java.time.temporal.TemporalField" "long"]))} (^java.lang.Object [this13334 G__13335 G__13336] #? (:cljs (.with ^java.time.Instant this13334 G__13335 G__13336) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__13335) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__13336)) (clojure.core/let [G__13335 ^"java.time.temporal.TemporalField" G__13335 G__13336 (clojure.core/long G__13336)] (.with ^java.time.Instant this13334 G__13335 G__13336)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalField") G__13335) (clojure.core/instance? (java.lang.Class/forName "java.lang.Long") G__13336)) (clojure.core/let [G__13335 ^"java.time.temporal.TemporalField" G__13335 G__13336 (clojure.core/long G__13336)] (.with ^java.time.Instant this13334 G__13335 G__13336)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))) (^java.lang.Object [this13337 G__13338] #? (:cljs (.with ^java.time.Instant this13337 G__13338) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__13338)) (clojure.core/let [G__13338 ^"java.time.temporal.TemporalAdjuster" G__13338] (.with ^java.time.Instant this13337 G__13338)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.temporal.TemporalAdjuster") G__13338)) (clojure.core/let [G__13338 ^"java.time.temporal.TemporalAdjuster" G__13338] (.with ^java.time.Instant this13337 G__13338)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn now {:arglists (quote ([] ["java.time.Clock"]))} (^java.time.Instant [] (. java.time.Instant now)) (^java.time.Instant [^java.time.Clock java-time-Clock13339] (. java.time.Instant now java-time-Clock13339)))
(clojure.core/defn to-epoch-milli {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this13340] (.toEpochMilli this13340)))
(clojure.core/defn get-epoch-second {:arglists (quote (["java.time.Instant"]))} (^long [^java.time.Instant this13341] (jti/getter epochSecond this13341)))
(clojure.core/defn compare-to {:arglists (quote (["java.time.Instant" "java.lang.Object"] ["java.time.Instant" "java.time.Instant"]))} (^java.lang.Integer [this13342 G__13343] #? (:cljs (.compareTo ^java.time.Instant this13342 G__13343) :clj (clojure.core/cond (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.lang.Object") G__13343)) (clojure.core/let [G__13343 ^"java.lang.Object" G__13343] (.compareTo ^java.time.Instant this13342 G__13343)) (clojure.core/and (clojure.core/instance? (java.lang.Class/forName "java.time.Instant") G__13343)) (clojure.core/let [G__13343 ^"java.time.Instant" G__13343] (.compareTo ^java.time.Instant this13342 G__13343)) :else (throw (java.lang.IllegalArgumentException. "no corresponding java.time method with these args"))))))
(clojure.core/defn plus-seconds {:arglists (quote (["java.time.Instant" "long"]))} (^java.time.Instant [^java.time.Instant this13344 ^long long13345] (.plusSeconds this13344 long13345)))
(clojure.core/defn get {:arglists (quote (["java.time.Instant" "java.time.temporal.TemporalField"]))} (^java.lang.Integer [^java.time.Instant this13346 ^java.time.temporal.TemporalField java-time-temporal-TemporalField13347] (.get this13346 java-time-temporal-TemporalField13347)))
(clojure.core/defn equals {:arglists (quote (["java.time.Instant" "java.lang.Object"]))} (^java.lang.Boolean [^java.time.Instant this13348 ^java.lang.Object java-lang-Object13349] (.equals this13348 java-lang-Object13349)))
